<application>
  <component name="AppStorage">
    <histories>
      <item value="Icon Tab Provider" />
      <item value="DECELERATION RATE" />
      <item value="* Returns Euler's number &lt;i&gt;e&lt;/i&gt; raised to the power of a * {@code double} value." />
      <item value="exp" />
      <item value="get Spline Fling Distance" />
      <item value="register Component" />
      <item value="fire Global Event Callback" />
      <item value="Sets the opacity of the view to a value from 0 to 1, where 0 means the view is * completely transparent and 1 means the view is completely opaque. *" />
      <item value="* Sets the opacity of the view to a value from 0 to 1, where 0 means the view is * completely transparent and 1 means the view is completely opaque." />
      <item value="blocks Descendants" />
      <item value="is Need Adjust Related View" />
      <item value="Only fullscreen opaque activities can request orientation" />
      <item value="platform" />
      <item value="jcenter" />
      <item value="Information you can retrieve about a running process." />
      <item value="The name of the process this application should run in." />
      <item value="/** * The name of the process this application should run in. From the * &quot;process&quot; attribute or, if not set, the same as * &lt;var&gt;packageName&lt;/var&gt;. */" />
      <item value="ould not determine the dependencies of task" />
      <item value="Only one Looper may be created per thread" />
      <item value="sThreadLocal.get() will return null unless you've called prepare()." />
      <item value="s Thread Local" />
      <item value="Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */" />
      <item value="Use Looper.myLooper() if looper is not specified." />
      <item value="Replace an existing fragment that was added to a container. This is * essentially the same as calling {@link #remove(Fragment)} for all * currently added fragments that were added with the same containerViewId * and then {@link #add(int, Fragment, String)} with the same arguments * given here." />
      <item value="he interval in millis that the user receives callbacks" />
      <item value="* Millis since epoch when alarm should stop." />
      <item value="seconds remaining" />
      <item value="Schedule a countdown until a time in the future, with * regular notifications on intervals along the way. *" />
      <item value="The amount of time until finished." />
      <item value="he amount of time until finished." />
      <item value="millis Until Finished" />
      <item value="on Tick" />
      <item value="The number of millis in the future from the call * to {@link #start()} until the countdown is done and {@link #onFinish()} * is called. * @param countDownInterval The interval along the way to receive * {@link #onTick(long)} callbacks." />
      <item value="ailed to transform file 'Msc.jar' to match attributes" />
      <item value="ould not resolve all files for configuration ':app:debugCompileClasspath'." />
      <item value="restore Save State" />
      <item value="move To State" />
      <item value="dump" />
      <item value="@deprecated use {@link #findViewHolderForLayoutPosition(int)} or * {@link #findViewHolderForAdapterPosition(int)}" />
      <item value="* * Return the ViewHolder for the item in the given position of the data set as of the latest * layout pass." />
      <item value="The position of the item in the data set of the adapter" />
      <item value="distribute Complete" />
      <item value="Affected" />
      <item value="Could not determine the dependencies of task ':flutter:compileDebugAidl'." />
      <item value="m Is Recyclable Count" />
      <item value="Informs the recycler whether this item can be recycled. Views which are not * recyclable will not be reused for other items until setIsRecyclable() is * later set to true. Calls to setIsRecyclable() should always be paired (one * call to setIsRecyclabe(false) should always be matched with a later call to * setIsRecyclable(true)). Pairs of calls may be nested, as the state is internally * reference-counted." />
      <item value="Return the ViewHolder for the item in the given position of the data set. Unlike * {@link #findViewHolderForLayoutPosition(int)} this method takes into account any pending * adapter changes that may not be reflected to the layout yet. On the other hand, if * {@link Adapter#notifyDataSetChanged()} has been called but the new layout has not been * calculated yet, this method will return &lt;code&gt;null&lt;/code&gt; since the new positions of views * are unknown until the layout is calculated." />
      <item value="Called by RecyclerView to display the data at the specified position. This method should * update the contents of the {@link ViewHolder#itemView} to reflect the item at the given * position." />
      <item value="airbnb" />
      <item value="multidex" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="890" />
        <entry key="ENGLISH" value="891" />
        <entry key="POLISH" value="3" />
        <entry key="DANISH" value="3" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALAYALAM" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>