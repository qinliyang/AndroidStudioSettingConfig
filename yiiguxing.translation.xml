<application>
  <component name="AppStorage">
    <histories>
      <item value="The camera device is in use already." />
      <item value="p&gt;&lt;code&gt;CameraAccessException&lt;/code&gt; is thrown if a camera device could not * be queried or opened by the {@link CameraManager}, or if the connection to an * opened {@link CameraDevice} is no longer valid.&lt;/p&gt;" />
      <item value="FATAL" />
      <item value="Return the {@link FragmentActivity} this fragment is currently associated with. * May return {@code null} if the fragment is associated with a {@link Context} * instead." />
      <item value="host Activity" />
      <item value="Called when a fragment is first attached to its activity. * {@link #onCreate(Bundle)} will be called after this. * * @deprecated See {@link #onAttach(Context)}." />
      <item value="Called when a fragment is first attached to its context. * {@link #onCreate(Bundle)} will be called after this." />
      <item value="Create a {@link CaptureRequest.Builder} for new capture requests, * initialized with template for a target use case. The settings are chosen * to be the best options for the specific camera device, so it is not * recommended to reuse the same request for a different camera device; * create a builder specific for that device and template and override the * settings as desired, instead.&lt;/p&gt; *" />
      <item value="Whether this item is available to be recycled. Default value * is true." />
      <item value="Informs the recycler whether this item can be recycled. Views which are not * recyclable will not be reused for other items until setIsRecyclable() is * later set to true. Calls to setIsRecyclable() should always be paired (one * call to setIsRecyclabe(false) should always be matched with a later call to * setIsRecyclable(true)). Pairs of calls may be nested, as the state is internally * reference-counted." />
      <item value="Return a private FragmentManager for placing and managing Fragments * inside of this Fragment." />
      <item value="Return the FragmentManager for interacting with fragments associated * with this activity." />
      <item value="Called to inform the adapter of which item is currently considered to * be the &quot;primary&quot;, that is the one show to the user as the current page. * This method will not be invoked when the adapter contains no items. *" />
      <item value="populate" />
      <item value="Set the currently selected page. If the ViewPager has already been through its first * layout there will be a smooth animated transition between the current item and the * specified item." />
      <item value="set Current Item Internal" />
      <item value="move To State" />
      <item value="Illegal Argument Exception" />
      <item value="Invocation Target Exception" />
      <item value="No resource identifier found for attribute 'appComponentFactory' in package 'android'" />
      <item value="@param prefix Text to print at the front of each line. * @param fd The raw file descriptor that the dump is being sent to. * @param writer The PrintWriter to which you should dump your state. This will be * closed for you after you return. * @param args additional arguments to the dump request." />
      <item value="Print the Fragments's state into the given stream." />
      <item value="dump" />
      <item value="Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance" />
      <item value="Container for fragments associated with an activity." />
      <item value=", do not add dropbox and clear mLastCrashedPid" />
      <item value="The same pid with last one" />
      <item value="No Preload View Pager" />
      <item value="Declared On Click Listener" />
      <item value="reflect" />
      <item value="INSTALL FAILED USER RESTRICTED" />
      <item value="Sets the minimum width of the view. It is not guaranteed the view will * be able to achieve this minimum width (for example, if its parent layout * constrains it with less available width). *" />
      <item value="search Season" />
      <item value="existing" />
      <item value="Hides an existing fragment. This is only relevant for fragments whose * views have been added to a container, as this will cause the view to * be hidden." />
      <item value="* Remove an existing fragment. If it was added to a container, its view * is also removed from that container. *" />
      <item value="* @return &lt;code&gt;true&lt;/code&gt; if this transaction contains no operations, * &lt;code&gt;false&lt;/code&gt; otherwise." />
      <item value="Detach the given fragment from the UI. This is the same state as * when it is put on the back stack: the fragment is removed from * the UI, however its state is still being actively managed by the * fragment manager. When going into this state its view hierarchy * is destroyed." />
      <item value="et a list of all fragments that are currently added to the FragmentManager. * This may include those that are hidden as well as those that are shown. * This will not include any fragments only in the back stack, or fragments that * are detached or removed. * &lt;p&gt; * The order of the fragments in the list is the order in which they were * added or attached." />
      <item value="Pop the top state off the back stack. Returns true if there was one * to pop, else false. This function is asynchronous -- it enqueues the * request to pop, but the action will not be performed until the application * returns to its event loop." />
      <item value="Negative to check scrolling up, positive to check scrolling down." />
      <item value="srl Enable Over Scroll Drag" />
      <item value="MILLISECONDS PER PX" />
      <item value="p&gt;Calculates the time for deceleration so that transition from LinearInterpolator to * DecelerateInterpolator looks" />
      <item value="SNAP TO START" />
      <item value="milliseconds" />
      <item value="calculate Speed Per Pixel" />
      <item value="&lt;p&gt;Calculates the time for deceleration so that transition from LinearInterpolator to * DecelerateInterpolator looks smooth.&lt;/p&gt; * * @param dx Distance to scroll * @return Time for DecelerateInterpolator to smoothly traverse the distance when transitioning * from LinearInterpolation" />
      <item value="In a case where dx is very small, rounding may return 0 although dx &gt; 0. // To avoid that issue, ceil the result so that if dx &gt; 0, we'll always return positive // time." />
      <item value="Calculates the time it should take to scroll the given distance (in pixels)" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="361" />
        <entry key="ENGLISH" value="362" />
        <entry key="POLISH" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>