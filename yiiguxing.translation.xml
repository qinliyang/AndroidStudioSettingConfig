<application>
  <component name="AppStorage">
    <histories>
      <item value="apply Transformation" />
      <item value="Float Animation" />
      <item value="* Attempts to get the ViewHolder for the given position, either from the Recycler scrap, * cache, the RecycledViewPool, or creating it directly. * &lt;p&gt;" />
      <item value="try Get View Holder For Position By Deadline" />
      <item value="The view does not have a ViewHolder." />
      <item value="he view does not have a ViewHolder. You cannot&quot; + &quot; pass arbitrary views to this method, they should be created by the &quot;" />
      <item value="** * {@link android.view.ViewGroup.MarginLayoutParams LayoutParams} subclass for children of * {@link RecyclerView}. Custom {@link LayoutManager layout managers} are encouraged * to create their own subclass of this &lt;code&gt;LayoutParams&lt;/code&gt; class * to store any additional required per-child view metadata about the layout. */" />
      <item value="RecyclerView provides artificial position range (item count) in pre-layout state and * automatically maps these positions to {@link Adapter} positions when * {@link #getViewForPosition(int)} or {@link #bindViewToPosition(View, int)} is called. * &lt;p&gt;" />
      <item value="Returns the adapter position of the ViewHolder in the latest layout pass. * @see #getAdapterPosition()" />
      <item value="* Returns the adapter position of the item represented by the given View. This does not * contain any adapter changes that might have happened after the last layout. *" />
      <item value="Returns the first child that is visible in the provided index range, i.e. either partially or // fully visible depending on the arguments provided. Completely invisible children are not // acceptable by this method, but could be returned // using #findOnePartiallyOrCompletelyInvisibleChild" />
      <item value="* Returns true if the {@link RecyclerView} is in the pre-layout step where it is having its * {@link LayoutManager} layout items where they will be at the beginning of a set of * predictive item animations." />
      <item value="validate View Holder For Offset Position" />
      <item value="don't check type if it is pre-layout." />
      <item value="* Mark an attached view as scrap." />
      <item value="Return the view type of the item at &lt;code&gt;position&lt;/code&gt; for the purposes * of view recycling." />
      <item value="get Slim Injector Actual Type Arguments" />
      <item value="Performs a bulk transaction on the given endpoint. * The direction of the transfer is determined by the direction of the endpoint. * * @param endpoint the endpoint for this transaction * @param buffer buffer for data to send or receive * @param offset the index of the first byte in the buffer to send or receive * @param length the length of the data to send or receive * @param timeout in milliseconds, 0 is infinite * @return length of data transferred (or zero) for success, * or negative value for failure" />
      <item value="LIVING" />
      <item value="The second layout step where we do the actual layout of the views for the final state. * This step might be run multiple times if necessary (e.g. measure). */ private void" />
      <item value="Layout state should be one of 100 but it is 10" />
      <item value="get Product Stock Complaint" />
      <item value="/** * Transform an Observable by applying a particular Transformer function to it. * &lt;p&gt;" />
      <item value="A {@linkplain CallAdapter.Factory call adapter} which uses RxJava for creating observables. * &lt;p&gt;" />
      <item value="failed" />
      <item value="Value in pixels indicating the offset from position." />
      <item value="Value from [0, 1) indicating the offset from the page at position." />
      <item value="You must not call setTag() on a view Glide is targeting" />
      <item value="Set or clear the shader object. * &lt;p /&gt; * Pass null to clear any previous shader. * As a convenience, the parameter passed is also returned. *" />
      <item value="Create a shader that draws a linear gradient along a line. * * @param x0 The x-coordinate for the start of the gradient line * @param y0 The y-coordinate for the start of the gradient line * @param x1 The x-coordinate for the end of the gradient line * @param y1 The y-coordinate for the end of the gradient line * @param color0 The color at the start of the gradient line. * @param color1 The color at the end of the gradient line. * @param tile The Shader tiling mode" />
      <item value="line below current tab" />
      <item value="* Draw the specified Rect using the specified paint. The rectangle will be filled or framed * based on the Style in the paint. * * @param left The left side of the re" />
      <item value="draw indicator line" />
      <item value="if there is an offset, start interpolating left and right coordinates between current and next tab" />
      <item value="psts Text All Caps" />
      <item value="set Children Drawing Order Enabled" />
      <item value="millis Until Finished" />
      <item value="The interval along the way to receive * {@link #onTick(long)} callbacks." />
      <item value="* @param millisInFuture The number of millis in the future from the call * to {@link #start()} until the countdown is done and {@link #onFinish()} * is called." />
      <item value="faild" />
      <item value="Manually shows the next child." />
      <item value="psts Underline Color" />
      <item value="Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop." />
      <item value="Run the message queue in this thread. Be sure to call" />
      <item value="* Set the resize threshold to maintain at worst a 2/3 load factor." />
      <item value="Construct a new map initially containing (firstKey, firstValue). * ThreadLocalMaps are constructed lazily, so we only create * one when we have at least one entry to put in it." />
      <item value="Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. *" />
      <item value="Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * {@link #loop()} after calling this method, and end it by calling * {@link #quit()}." />
      <item value="quit Allowed" />
      <item value="Only one Looper may be created per thread" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="953" />
        <entry key="ENGLISH" value="954" />
        <entry key="POLISH" value="3" />
        <entry key="DANISH" value="3" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALAYALAM" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>